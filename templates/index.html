{% extends "base.html" %}

{% block title %}Photobooth{% endblock %}

{% block content %}
<div class="camera-fullscreen" id="videoContainer">
    <style>
    body {
        background: #000 !important;
    }

    .container-fluid {
        padding: 0 !important;
    }

    .camera-fullscreen {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
        overflow: hidden;
    }

    .camera-video-wrapper {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
    }

    #cameraVideo,
    #cameraFallbackImage {
        width: 100%;
        height: 100%;
        object-fit: cover;
        background: #000;
    }

    #cameraStatusChip {
        position: absolute;
        top: 1rem;
        right: 1rem;
        z-index: 20;
    }

    .camera-controls {
        position: absolute;
        bottom: 3rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 1.5rem;
        z-index: 10;
    }

    #captureBtn {
        border-radius: 50%;
        width: 5rem;
        height: 5rem;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 2rem;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    #usbManagerBtn {
        border-radius: 1.5rem;
        padding: 1rem 1.5rem;
        font-size: 1.1rem;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .camera-error-banner {
        position: absolute;
        top: 2rem;
        left: 50%;
        transform: translateX(-50%);
        max-width: 90vw;
        z-index: 20;
    }

    .countdown {
        position: fixed;
    }

    @media (max-width: 800px) {
        .camera-controls {
            bottom: 2rem;
            gap: 1rem;
        }

        #captureBtn {
            width: 4rem;
            height: 4rem;
            font-size: 1.5rem;
        }

        #usbManagerBtn {
            padding: 0.75rem 1.25rem;
            font-size: 1rem;
        }
    }

    .usb-photo-item {
        border-radius: 15px;
        overflow: hidden;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
    }

    .usb-photo-item:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
    }

    .usb-photo-item.active {
        border: 3px solid #1e88e5;
        box-shadow: 0 8px 20px rgba(30, 136, 229, 0.35);
    }

    .usb-photo-item img {
        object-fit: cover;
        width: 100%;
        height: 100%;
    }
    </style>

    <div id="cameraErrorBanner" class="alert alert-warning d-none camera-error-banner" role="alert">
        <div id="cameraErrorBannerTitle" class="fw-bold">Statut caméra</div>
        <div id="cameraErrorBannerText" class="mt-2"></div>
        <div id="cameraErrorBannerDetails" class="small text-muted mt-2"></div>
        <div class="d-flex gap-2 mt-3">
            <button class="btn btn-outline-light btn-sm" id="cameraRetryButton">
                <i class="fas fa-sync-alt me-2"></i>
                Réessayer
            </button>
            <button class="btn btn-outline-warning btn-sm" id="cameraDiagnosticButton">
                <i class="fas fa-stethoscope me-2"></i>
                Diagnostic
            </button>
        </div>
    </div>

    <div id="cameraVideoWrapper" class="camera-video-wrapper">
        <video id="cameraVideo"
               autoplay
               playsinline
               muted>
        </video>
        <img id="cameraFallbackImage"
             class="d-none"
             alt="Capture système (8080)">
        <span id="planBBadge" class="badge bg-warning text-dark position-absolute top-0 start-0 m-3 d-none">Capture système (8080)</span>
        <span id="cameraStatusChip" class="badge bg-info text-dark">Caméra locale : vérification…</span>
    </div>

    <div class="camera-controls">
        <button id="captureBtn" class="btn btn-danger btn-lg" onclick="capturePhoto()">
            <i class="fas fa-camera"></i>
        </button>
        <button id="usbManagerBtn" class="btn btn-usb btn-lg" onclick="openUsbManager()">
            <i class="fas fa-usb me-2"></i>
            Clé USB
        </button>
    </div>
</div>

<div class="countdown d-none position-fixed top-50 start-50 translate-middle" id="countdown"></div>

<div class="flash-overlay d-none position-fixed top-0 start-0 w-100 h-100" id="flashOverlay"
     style="background-color: white; z-index: 15; display: flex; align-items: center; justify-content: center;">
    <div style="font-size: 8rem; font-weight: bold; color: black; text-shadow: none;">CHEESE!</div>
</div>

<!-- Alerte manque de papier -->
<div class="position-fixed top-0 start-50 translate-middle-x mt-3" style="z-index: 20; width: 90%; max-width: 500px;">
    <div class="alert alert-warning d-none d-flex align-items-center" id="paper-alert" style="border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
        <i class="fas fa-exclamation-triangle me-2"></i>
        <div>
            <strong>Attention !</strong><br>
            <small>Vérifiez le papier de l'imprimante avant de prendre une photo</small>
        </div>
    </div>
</div>

<!-- Modale diagnostic caméra -->
<div class="modal fade" id="cameraDiagnosticModal" tabindex="-1" aria-labelledby="cameraDiagnosticModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header bg-dark text-white">
                <h5 class="modal-title" id="cameraDiagnosticModalLabel">
                    <i class="fas fa-stethoscope me-2"></i>
                    Diagnostic caméra
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Fermer"></button>
            </div>
            <div class="modal-body">
                <p class="text-muted small mb-3">Dernière exécution : <span id="cameraDiagnosticTimestamp">–</span></p>
                <h6>Caméras détectées par le navigateur</h6>
                <ul id="cameraDiagnosticDevices" class="list-group mb-4"></ul>
                <h6>État backend <code>/camera/health</code></h6>
                <pre id="cameraHealthDump" class="bg-dark text-success p-3 rounded" style="min-height: 160px; max-height: 320px; overflow: auto; font-size: 0.85rem;"></pre>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                    <i class="fas fa-times me-2"></i>
                    Fermer
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Modale de gestion USB -->
<div class="modal fade" id="usbManagerModal" tabindex="-1" aria-labelledby="usbManagerModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header" style="background: linear-gradient(45deg, #1e88e5, #1565c0); color: #fff;">
                <h5 class="modal-title" id="usbManagerModalLabel">
                    <i class="fas fa-usb me-2"></i>
                    Gestion des photos USB
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Fermer"></button>
            </div>
            <div class="modal-body">
                <div id="usbManagerAlert" class="alert alert-warning d-none" role="alert">
                    Aucune clé USB détectée. Branchez une clé et cliquez sur Rafraîchir.
                </div>
                <div id="usbManagerContent">
                    <div class="row g-4">
                        <div class="col-lg-7">
                            <div id="usbPhotosContainer" class="row g-3"></div>
                        </div>
                        <div class="col-lg-5">
                            <div class="card bg-dark text-white h-100 shadow-sm">
                                <div class="card-body d-flex flex-column justify-content-center" id="usbPhotoPreview">
                                    <p class="text-muted text-center mb-0">Sélectionnez une photo pour l'aperçu.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer d-flex justify-content-between">
                <div>
                    <small class="text-muted" id="usbMountInfo"></small>
                </div>
                <div class="d-flex gap-2">
                    <button type="button" class="btn btn-usb" id="usbRefreshBtn">
                        <i class="fas fa-sync-alt me-2"></i>
                        Rafraîchir
                    </button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                        <i class="fas fa-times me-2"></i>
                        Fermer
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Overlay diaporama -->
<div id="slideshowOverlay" class="d-none" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; z-index: 9999; display: flex; align-items: center; justify-content: center;">
    <div class="slideshow-container" style="width: 100%; height: 100%; position: relative;">
        <img id="slideshowImage" 
             style="width: 100%; height: 100%; object-fit: contain;" 
             alt="Photo du diaporama">
        
        <!-- Indicateur de progression -->
        <div class="slideshow-info position-absolute bottom-0 start-0 end-0 p-4 text-white" style="background: linear-gradient(transparent, rgba(0,0,0,0.7));">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <h5 class="mb-1" id="slideshowTitle">Diaporama</h5>
                    <small id="slideshowCounter">Photo 1 sur 10</small>
                </div>
                <div class="text-end">
                    <small class="text-muted">Appuyez sur l'écran pour revenir</small>
                </div>
            </div>

        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script type="module">
const CAMERA_SERVICE_BASE = window.SIMPLEBOOTH_CAMERA_SERVER
    || `${window.location.protocol}//${window.location.hostname}:8080`;

let isCapturing = false;
let usbManagerModal = null;
let usbPhotos = [];
let selectedUsbPhotoName = null;

let localStream = null;
let usingBrowserCamera = false;
let usingHttpFallback = false;
let lastFallbackUrl = null;

const videoElement = document.getElementById('cameraVideo');
const fallbackImage = document.getElementById('cameraFallbackImage');
const planBBadge = document.getElementById('planBBadge');
const statusChip = document.getElementById('cameraStatusChip');
const errorBanner = document.getElementById('cameraErrorBanner');
const errorBannerTitle = document.getElementById('cameraErrorBannerTitle');
const errorBannerText = document.getElementById('cameraErrorBannerText');
const errorBannerDetails = document.getElementById('cameraErrorBannerDetails');
const retryButton = document.getElementById('cameraRetryButton');
const diagnosticButton = document.getElementById('cameraDiagnosticButton');
const diagnosticsModal = document.getElementById('cameraDiagnosticModal');
const diagnosticsDevicesList = document.getElementById('cameraDiagnosticDevices');
const diagnosticsHealthPre = document.getElementById('cameraHealthDump');
const diagnosticsTimestamp = document.getElementById('cameraDiagnosticTimestamp');

document.addEventListener('DOMContentLoaded', async () => {
    await initialiseCamera();

    if (retryButton) {
        retryButton.addEventListener('click', handleCameraRetry);
    }
    if (diagnosticButton) {
        diagnosticButton.addEventListener('click', openCameraDiagnostics);
    }

    const refreshBtn = document.getElementById('usbRefreshBtn');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', () => refreshUsbPhotos());
    }
    const modalEl = document.getElementById('usbManagerModal');
    if (modalEl) {
        modalEl.addEventListener('hidden.bs.modal', () => {
            selectedUsbPhotoName = null;
            updateUsbPreview(null);
            highlightSelectedUsb(null);
        });
    }
});

function describeError(error) {
    if (!error) {
        return 'Erreur inconnue';
    }
    if (typeof error === 'string') {
        return error;
    }
    const name = error.name || error.constructor?.name || 'Erreur';
    const message = error.message || String(error);
    return `${name}: ${message}`;
}

function showCameraMessage(message, details = '', variant = 'warning', title = 'Statut caméra') {
    if (!errorBanner) {
        return;
    }

    errorBanner.classList.remove('d-none', 'alert-danger', 'alert-warning', 'alert-info', 'alert-success');
    errorBanner.classList.add(`alert-${variant}`);

    if (errorBannerTitle) {
        errorBannerTitle.textContent = title;
    }
    if (errorBannerText) {
        errorBannerText.textContent = message;
    }
    if (errorBannerDetails) {
        errorBannerDetails.textContent = details || '';
        errorBannerDetails.classList.toggle('d-none', !details);
    }
}

function hideCameraMessage() {
    if (!errorBanner) {
        return;
    }
    errorBanner.classList.add('d-none');
    errorBanner.classList.remove('alert-danger', 'alert-warning', 'alert-info', 'alert-success');
    if (errorBannerText) {
        errorBannerText.textContent = '';
    }
    if (errorBannerDetails) {
        errorBannerDetails.textContent = '';
        errorBannerDetails.classList.add('d-none');
    }
}

function setStatusChip(text, variant = 'info') {
    if (!statusChip) {
        return;
    }
    const classesToRemove = ['bg-info', 'bg-success', 'bg-danger', 'bg-warning', 'text-dark', 'text-white'];
    statusChip.classList.remove(...classesToRemove);

    if (variant === 'success') {
        statusChip.classList.add('bg-success', 'text-white');
    } else if (variant === 'danger') {
        statusChip.classList.add('bg-danger', 'text-white');
    } else if (variant === 'warning') {
        statusChip.classList.add('bg-warning', 'text-dark');
    } else {
        statusChip.classList.add('bg-info', 'text-dark');
    }

    statusChip.textContent = text;
}

async function requestCameraHealth() {
    const url = `${CAMERA_SERVICE_BASE}/health`;
    try {
        const response = await fetch(url, {
            method: 'GET',
            mode: 'cors',
            cache: 'no-store',
        });
        let payload = null;
        try {
            payload = await response.json();
        } catch (jsonError) {
            payload = { ok: false, error: 'Réponse JSON invalide' };
        }
        if (!payload || typeof payload !== 'object') {
            payload = { ok: false, error: 'Réponse inattendue' };
        }
        const ok = response.ok && payload && payload.ok === true;
        return { ok, payload, response };
    } catch (error) {
        return {
            ok: false,
            payload: { ok: false, error: describeError(error) },
            response: null,
        };
    }
}

async function updateCameraHealthIndicator() {
    const result = await requestCameraHealth();
    if (result.ok) {
        setStatusChip('Caméra locale prête', 'success');
    } else {
        setStatusChip('Caméra locale indisponible', 'danger');
    }
    return result;
}

async function ensureVideoReady(video) {
    if (!video) {
        return;
    }
    if (video.readyState >= 2 && video.videoWidth && video.videoHeight) {
        return;
    }
    await new Promise((resolve) => {
        const cleanup = () => {
            video.removeEventListener('loadeddata', cleanup);
            video.removeEventListener('loadedmetadata', cleanup);
            resolve();
        };
        video.addEventListener('loadeddata', cleanup, { once: true });
        video.addEventListener('loadedmetadata', cleanup, { once: true });
    });
}

function stopLocalStream() {
    if (localStream) {
        localStream.getTracks().forEach((track) => track.stop());
    }
    if (videoElement) {
        videoElement.srcObject = null;
    }
    localStream = null;
    usingBrowserCamera = false;
}

async function startBrowserCamera() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('API getUserMedia indisponible');
    }

    stopLocalStream();
    try {
        localStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: { ideal: 'environment' } },
            audio: false,
        });
    } catch (error) {
        localStream = null;
        throw error;
    }

    usingBrowserCamera = true;
    usingHttpFallback = false;
    if (videoElement) {
        videoElement.classList.remove('d-none');
        videoElement.srcObject = localStream;
        await ensureVideoReady(videoElement);
    }
    if (fallbackImage) {
        fallbackImage.classList.add('d-none');
    }
    if (planBBadge) {
        planBBadge.classList.add('d-none');
    }
    hideCameraMessage();
}

function revokeFallbackUrl() {
    if (lastFallbackUrl) {
        URL.revokeObjectURL(lastFallbackUrl);
        lastFallbackUrl = null;
    }
}

function displayFallbackImage(blob) {
    if (!fallbackImage) {
        return;
    }
    revokeFallbackUrl();
    lastFallbackUrl = URL.createObjectURL(blob);
    fallbackImage.src = lastFallbackUrl;
}

async function fetchSnapshotBlob() {
    const response = await fetch(`${CAMERA_SERVICE_BASE}/snapshot`, {
        method: 'GET',
        mode: 'cors',
        cache: 'no-store',
    });
    if (!response.ok) {
        const text = await response.text();
        throw new Error(text || `Erreur ${response.status}`);
    }
    return await response.blob();
}

async function refreshFallbackPreview() {
    try {
        const blob = await fetchSnapshotBlob();
        if (fallbackImage) {
            fallbackImage.classList.remove('d-none');
        }
        if (planBBadge) {
            planBBadge.classList.remove('d-none');
        }
        displayFallbackImage(blob);
    } catch (error) {
        const message = "Service caméra indisponible (8080). Vérifie qu'il tourne : sudo systemctl status camera-service.";
        showCameraMessage(message, describeError(error), 'danger');
    }
}

async function activateHttpFallback(reason) {
    stopLocalStream();
    usingHttpFallback = true;
    usingBrowserCamera = false;

    if (videoElement) {
        videoElement.classList.add('d-none');
    }
    if (fallbackImage) {
        fallbackImage.classList.remove('d-none');
    }
    if (planBBadge) {
        planBBadge.classList.remove('d-none');
    }

    const permissionDenied = reason && ['NotAllowedError', 'SecurityError'].includes(reason.name);
    const message = permissionDenied
        ? 'Caméra navigateur refusée → bascule sur capture système (8080)…'
        : 'Capture navigateur indisponible → bascule sur capture système (8080)…';
    showCameraMessage(message, describeError(reason), 'warning');
    await updateCameraHealthIndicator();
    await refreshFallbackPreview();
}

async function initialiseCamera() {
    await updateCameraHealthIndicator();

    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        await activateHttpFallback(new Error('API getUserMedia indisponible sur ce navigateur'));
        return;
    }

    try {
        await startBrowserCamera();
    } catch (error) {
        console.warn('Impossible de démarrer la caméra navigateur, bascule sur fallback HTTP', error);
        await activateHttpFallback(error);
    }
}

async function handleCameraRetry(event) {
    event?.preventDefault?.();
    hideCameraMessage();
    try {
        await startBrowserCamera();
    } catch (error) {
        await activateHttpFallback(error);
    }
}

async function listVideoDevices() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        return { devices: [], error: 'API enumerateDevices indisponible' };
    }
    try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        return { devices: devices.filter((device) => device.kind === 'videoinput'), error: null };
    } catch (error) {
        return { devices: [], error: describeError(error) };
    }
}

function renderDiagnosticsDevices(devices, errorMessage) {
    if (!diagnosticsDevicesList) {
        return;
    }
    diagnosticsDevicesList.innerHTML = '';

    if (errorMessage) {
        const li = document.createElement('li');
        li.className = 'list-group-item list-group-item-danger';
        li.textContent = errorMessage;
        diagnosticsDevicesList.appendChild(li);
        return;
    }

    if (!devices.length) {
        const li = document.createElement('li');
        li.className = 'list-group-item';
        li.textContent = 'Aucune caméra détectée par le navigateur.';
        diagnosticsDevicesList.appendChild(li);
        return;
    }

    devices.forEach((device, index) => {
        const li = document.createElement('li');
        li.className = 'list-group-item';
        const label = device.label || `Caméra ${index + 1}`;
        li.innerHTML = `<strong>${label}</strong><br><small>ID: ${device.deviceId || 'inconnu'}</small>`;
        diagnosticsDevicesList.appendChild(li);
    });
}

async function openCameraDiagnostics(event) {
    event?.preventDefault?.();
    const { devices, error } = await listVideoDevices();
    renderDiagnosticsDevices(devices, error);

    const health = await requestCameraHealth();
    if (diagnosticsHealthPre) {
        diagnosticsHealthPre.textContent = JSON.stringify(health.payload, null, 2);
    }
    if (diagnosticsTimestamp) {
        diagnosticsTimestamp.textContent = new Date().toLocaleString('fr-FR');
    }

    const modalLib = window.bootstrap?.Modal;
    if (modalLib && diagnosticsModal) {
        modalLib.getOrCreateInstance(diagnosticsModal).show();
    }
}

async function captureFromVideo() {
    if (!videoElement) {
        throw new Error('Aucune vidéo active');
    }
    await ensureVideoReady(videoElement);

    const width = videoElement.videoWidth || 1280;
    const height = videoElement.videoHeight || 720;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext('2d');
    if (!context) {
        throw new Error("Impossible d'accéder au contexte canvas");
    }
    context.drawImage(videoElement, 0, 0, width, height);

    return await new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (blob) {
                resolve(blob);
            } else {
                reject(new Error("Impossible de générer l'image"));
            }
        }, 'image/jpeg', 0.92);
    });
}

async function takePhoto() {
    const health = await updateCameraHealthIndicator();

    if (localStream && usingBrowserCamera) {
        const blob = await captureFromVideo();
        return { blob, origin: 'browser' };
    }

    if (!health.ok) {
        const message = "Service caméra indisponible (8080). Vérifie qu'il tourne : sudo systemctl status camera-service.";
        const details = health.payload?.error ? String(health.payload.error) : '';
        showCameraMessage(message, details, 'danger');
        throw new Error(message);
    }

    try {
        const blob = await fetchSnapshotBlob();
        usingHttpFallback = true;
        if (fallbackImage) {
            fallbackImage.classList.remove('d-none');
        }
        if (planBBadge) {
            planBBadge.classList.remove('d-none');
        }
        displayFallbackImage(blob);
        return { blob, origin: 'http-fallback' };
    } catch (error) {
        const message = "Service caméra indisponible (8080). Vérifie qu'il tourne : sudo systemctl status camera-service.";
        showCameraMessage(message, describeError(error), 'danger');
        throw new Error(message);
    }
}

window.addEventListener('beforeunload', () => {
    stopLocalStream();
    revokeFallbackUrl();
});

function capturePhoto() {
    if (isCapturing) return;
    
    isCapturing = true;
    const captureBtn = document.getElementById('captureBtn');
    const countdown = document.getElementById('countdown');
    
    // Désactiver le bouton
    captureBtn.disabled = true;
    captureBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    
    // Démarrer le compte à rebours
    let timeLeft = parseInt('{{ timer }}');
    countdown.classList.remove('d-none');
    
    const countdownInterval = setInterval(() => {
        countdown.textContent = timeLeft;
        timeLeft--;
        
        if (timeLeft < 0) {
            clearInterval(countdownInterval);
            countdown.textContent = 'CHEESE!';
            
            // Déclencher le flash blanc
            setTimeout(() => {
                countdown.classList.add('d-none');
                const flashOverlay = document.getElementById('flashOverlay');
                flashOverlay.classList.remove('d-none');
                
                // Masquer le flash après un court délai et prendre la photo
                setTimeout(() => {
                    flashOverlay.classList.add('d-none');
                    takePicture();
                }, 300);
            }, 200);
        }
    }, 1000);
}

async function takePicture() {
    let redirected = false;
    try {
        const { blob, origin } = await takePhoto();
        const formData = new FormData();
        formData.append('image', blob, `capture_${Date.now()}.jpg`);
        formData.append('origin', origin);

        const response = await fetch('/capture', {
            method: 'POST',
            body: formData,
        });

        const result = await response.json();

        if (response.ok && result.success) {
            redirected = true;
            resetCaptureButton();
            window.location.href = '/review';
            return;
        }

        const errorMessage = result.error || 'Erreur de capture';
        throw new Error(errorMessage);
    } catch (error) {
        console.error('Erreur lors de la capture:', error);
        alert('Erreur lors de la prise de photo: ' + (error.message || error));
    } finally {
        if (!redirected) {
            resetCaptureButton();
        }
    }
}

function openUsbManager() {
    if (!usbManagerModal) {
        const modalElement = document.getElementById('usbManagerModal');
        const modalLib = window.bootstrap;
        if (!modalLib || !modalLib.Modal) {
            console.warn('Bootstrap Modal non disponible');
            return;
        }
        usbManagerModal = new modalLib.Modal(modalElement);
    }
    refreshUsbPhotos();
    usbManagerModal.show();
}

window.capturePhoto = capturePhoto;
window.openUsbManager = openUsbManager;

async function refreshUsbPhotos(showToastOnError = false) {
    const container = document.getElementById('usbPhotosContainer');
    const alertBox = document.getElementById('usbManagerAlert');
    const mountInfo = document.getElementById('usbMountInfo');

    if (container) {
        container.innerHTML = `
            <div class="col-12 text-center text-muted py-5">
                <i class="fas fa-spinner fa-spin fa-2x mb-3"></i>
                <div>Chargement des photos...</div>
            </div>
        `;
    }
    if (alertBox) {
        alertBox.classList.add('d-none');
    }
    if (mountInfo) {
        mountInfo.textContent = '';
    }

    try {
        const response = await fetch('/usb/photos');
        const result = await response.json();
        if (!response.ok || !result.success) {
            throw new Error(result.error || 'Erreur lors du chargement de la clé USB');
        }

        usbPhotos = result.photos || [];
        if (mountInfo && result.mount_point) {
            mountInfo.textContent = `Montage : ${result.mount_point}`;
        }

        renderUsbPhotos();
        if (!usbPhotos.length && container) {
            container.innerHTML = `
                <div class="col-12 text-center text-muted py-5">
                    Aucune photo dans le dossier SimpleBooth.
                </div>
            `;
            updateUsbPreview(null);
        }
    } catch (error) {
        console.error('Erreur lors du chargement USB:', error);
        if (alertBox) {
            const message = error.message && !error.message.includes('Aucune clé USB détectée')
                ? error.message
                : 'Aucune clé USB détectée. Branchez une clé et cliquez sur Rafraîchir.';
            alertBox.textContent = message;
            alertBox.classList.remove('d-none');
            if (showToastOnError) {
                showToast(message, 'error');
            }
        }
        if (container) {
            container.innerHTML = '';
        }
        if (mountInfo) {
            mountInfo.textContent = '';
        }
        usbPhotos = [];
        selectedUsbPhotoName = null;
        updateUsbPreview(null);
        highlightSelectedUsb(null);
    }
}

function renderUsbPhotos() {
    const container = document.getElementById('usbPhotosContainer');
    if (!container) return;

    container.innerHTML = '';
    usbPhotos.forEach(photo => {
        const col = document.createElement('div');
        col.className = 'col-6 col-md-4 col-xl-3';

        const card = document.createElement('div');
        card.className = 'usb-photo-item card h-100 border-0 shadow-sm';
        card.dataset.name = photo.name;

        card.innerHTML = `
            <div class="ratio ratio-4x3">
                <img src="${photo.url}" alt="${photo.name}" class="w-100 h-100">
            </div>
            <div class="card-body p-3">
                <div class="fw-bold text-truncate" title="${photo.name}">${photo.name}</div>
                <div class="small text-muted">${formatBytes(photo.size)}</div>
                <div class="small text-muted">${formatDate(photo.mtime)}</div>
            </div>
        `;

        card.addEventListener('click', () => {
            selectedUsbPhotoName = photo.name;
            highlightSelectedUsb(photo.name);
            updateUsbPreview(photo);
        });

        if (photo.name === selectedUsbPhotoName) {
            card.classList.add('active');
        }

        col.appendChild(card);
        container.appendChild(col);
    });

    if (selectedUsbPhotoName) {
        const selectedPhoto = usbPhotos.find(photo => photo.name === selectedUsbPhotoName);
        if (selectedPhoto) {
            updateUsbPreview(selectedPhoto);
            highlightSelectedUsb(selectedUsbPhotoName);
            return;
        }
    }

    updateUsbPreview(null);
}

function updateUsbPreview(photo) {
    const preview = document.getElementById('usbPhotoPreview');
    if (!preview) return;

    if (!photo) {
        preview.innerHTML = '<p class="text-muted text-center mb-0">Sélectionnez une photo pour l\'aperçu.</p>';
        return;
    }

    preview.innerHTML = `
        <div class="w-100 mb-3 text-center">
            <img src="${photo.url}" alt="${photo.name}" class="img-fluid rounded shadow" style="max-height: 320px; object-fit: contain;">
        </div>
        <div class="w-100">
            <h5 class="mb-2">${photo.name}</h5>
            <p class="mb-1"><strong>Taille :</strong> ${formatBytes(photo.size)}</p>
            <p class="mb-3"><strong>Date :</strong> ${formatDate(photo.mtime)}</p>
            <div class="d-flex flex-column flex-sm-row gap-2">
                <button type="button" class="btn btn-danger flex-grow-1" id="usbDeleteBtn">
                    <i class="fas fa-trash me-2"></i>Supprimer
                </button>
                <button type="button" class="btn btn-outline-light flex-grow-1" id="usbKeepBtn">
                    <i class="fas fa-check me-2"></i>Conserver
                </button>
            </div>
        </div>
    `;

    const deleteBtn = document.getElementById('usbDeleteBtn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', () => confirmDeleteUsbPhoto(photo.name));
    }

    const keepBtn = document.getElementById('usbKeepBtn');
    if (keepBtn) {
        keepBtn.addEventListener('click', closeUsbPreview);
    }
}

function highlightSelectedUsb(name) {
    document.querySelectorAll('#usbPhotosContainer .usb-photo-item').forEach(item => {
        item.classList.toggle('active', !!name && item.dataset.name === name);
    });
}

function closeUsbPreview() {
    selectedUsbPhotoName = null;
    updateUsbPreview(null);
    highlightSelectedUsb(null);
}

async function confirmDeleteUsbPhoto(name) {
    if (!confirm('Êtes-vous sûr ?')) {
        return;
    }
    try {
        const response = await fetch(`/usb/photo/${encodeURIComponent(name)}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        const result = await response.json();
        if (!response.ok || !result.success) {
            throw new Error(result.error || 'Erreur lors de la suppression');
        }
        showToast('Photo supprimée de la clé USB.', 'success');
        selectedUsbPhotoName = null;
        await refreshUsbPhotos(true);
    } catch (error) {
        console.error('Erreur lors de la suppression USB:', error);
        showToast(error.message || 'Erreur lors de la suppression', 'error');
    }
}

function formatBytes(bytes) {
    if (!Number.isFinite(bytes)) {
        return '-';
    }
    const units = ['o', 'Ko', 'Mo', 'Go'];
    let index = 0;
    let value = bytes;
    while (value >= 1024 && index < units.length - 1) {
        value /= 1024;
        index += 1;
    }
    return `${value.toFixed(value < 10 && index > 0 ? 1 : 0)} ${units[index]}`;
}

function formatDate(timestamp) {
    try {
        return new Date(timestamp * 1000).toLocaleString('fr-FR');
    } catch (error) {
        return '-';
    }
}

function resetCaptureButton() {
    isCapturing = false;
    const captureBtn = document.getElementById('captureBtn');
    captureBtn.disabled = false;
    captureBtn.innerHTML = '<i class="fas fa-camera fa-2x"></i>';
}

// Variables pour le diaporama
let slideshowConfig = null;
let slideshowPhotos = [];
let slideshowActive = false;
let slideshowIndex = 0;
let slideshowInterval = null;

let inactivityTimer = null;
let lastActivity = Date.now();

// Initialiser le diaporama au chargement
document.addEventListener('DOMContentLoaded', function() {
    loadSlideshowConfig();
    setupActivityTracking();
});

async function loadSlideshowConfig() {
    try {
        const response = await fetch('/api/slideshow');
        slideshowConfig = await response.json();
        
        if (slideshowConfig.enabled && slideshowConfig.photos.length > 0) {
            slideshowPhotos = slideshowConfig.photos;
            startInactivityTimer();
        }
    } catch (error) {
        console.error('Erreur chargement config diaporama:', error);
    }
}

function setupActivityTracking() {
    // Détecter l'activité utilisateur
    ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'].forEach(event => {
        document.addEventListener(event, resetInactivityTimer, true);
    });
}

function resetInactivityTimer() {
    lastActivity = Date.now();
    
    if (slideshowActive) {
        // Si le diaporama est actif, le fermer
        stopSlideshow();
        return;
    }
    
    // Redémarrer le timer d'inactivité
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
    }
    
    if (slideshowConfig && slideshowConfig.enabled && slideshowPhotos.length > 0) {
        startInactivityTimer();
    }
}

function startInactivityTimer() {
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
    }
    
    inactivityTimer = setTimeout(() => {
        if (!slideshowActive && slideshowPhotos.length > 0) {
            startSlideshow();
        }
    }, slideshowConfig.delay * 1000);
}

function startSlideshow() {
    if (slideshowPhotos.length === 0) return;
    
    slideshowActive = true;
    slideshowIndex = 0;
    
    const overlay = document.getElementById('slideshowOverlay');
    overlay.classList.remove('d-none');
    overlay.style.display = 'flex';
    
    // Ajouter l'événement de clic pour fermer
    overlay.addEventListener('click', stopSlideshow);
    
    showCurrentSlide();
    
    // Démarrer la rotation automatique (5 secondes par photo)
    slideshowInterval = setInterval(() => {
        nextSlide();
    }, 5000);
    

}

function stopSlideshow() {
    slideshowActive = false;
    
    const overlay = document.getElementById('slideshowOverlay');
    overlay.classList.add('d-none');
    overlay.style.display = 'none';
    
    // Nettoyer les intervals
    if (slideshowInterval) {
        clearInterval(slideshowInterval);
        slideshowInterval = null;
    }
    

    
    // Redémarrer le timer d'inactivité
    startInactivityTimer();
}

function showCurrentSlide() {
    if (slideshowPhotos.length === 0) return;
    
    const image = document.getElementById('slideshowImage');
    const counter = document.getElementById('slideshowCounter');
    
    image.src = `/photos/${slideshowPhotos[slideshowIndex]}`;
    counter.textContent = `Photo ${slideshowIndex + 1} sur ${slideshowPhotos.length}`;
    

}

function nextSlide() {
    slideshowIndex = (slideshowIndex + 1) % slideshowPhotos.length;
    showCurrentSlide();

}



// Vérifier le statut de l'imprimante pour l'alerte papier
function checkPrinterPaperStatus() {
    fetch('/api/printer_status')
        .then(response => response.json())
        .then(data => {
            const paperAlert = document.getElementById('paper-alert');
            
            // Afficher l'alerte seulement si l'imprimante est activée et qu'il y a un problème de papier
            if (data.status === 'ok' && data.paper_status && data.paper_status !== 'ok' && data.paper_status !== 'unknown') {
                paperAlert.classList.remove('d-none');
            } else {
                paperAlert.classList.add('d-none');
            }
        })
        .catch(error => {
            console.error('Erreur vérification papier:', error);
            // Masquer l'alerte en cas d'erreur
            document.getElementById('paper-alert').classList.add('d-none');
        });
}

// Vérifier le papier au chargement et périodiquement
document.addEventListener('DOMContentLoaded', function() {
    // Vérifier si on doit forcer l'affichage de l'alerte papier
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('show_paper_alert') === '1') {
        // Forcer l'affichage de l'alerte
        const paperAlert = document.getElementById('paper-alert');
        paperAlert.classList.remove('d-none');
        
        // Nettoyer l'URL sans recharger la page
        const newUrl = window.location.pathname;
        window.history.replaceState({}, document.title, newUrl);
    }
    
    checkPrinterPaperStatus();
    // Vérifier toutes les 30 secondes
    setInterval(checkPrinterPaperStatus, 30000);
});

// Nettoyer les ressources lors de la fermeture
window.addEventListener('beforeunload', function() {
    fetch('/stop_camera').catch(error => {
        console.log('Erreur arrêt caméra:', error);
    });
});
</script>
{% endblock %}
